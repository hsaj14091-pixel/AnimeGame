<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ù…Ø²Ø§Ù…Ù†Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª</title>
    <style>
        body { background: #1a1a1a; color: white; font-family: sans-serif; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; margin: 0; text-align: center; }
        .loader { border: 5px solid #333; border-top: 5px solid #f39c12; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .status-box { background: rgba(255,255,255,0.05); padding: 30px; border-radius: 15px; border: 1px solid #444; width: 350px; }
        .log { font-size: 0.8rem; color: #777; margin-top: 10px; border-top: 1px solid #333; padding-top: 5px; text-align: left; direction: ltr; max-height: 100px; overflow-y: auto; }
    </style>
</head>
<body>

    <div class="status-box">
        <div class="loader"></div>
        <h3 style="color:#f39c12">Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...</h3>
        <p id="status-text">Ø¬Ù„Ø¨ ÙˆÙØ­Øµ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ğŸ§</p>
        <div id="log-area" class="log"></div>
    </div>

    <script>
        const username = "{{ username }}";
        const selectedStatuses = {{ statuses | tojson }}; 

        const proxies = [
            { name: "AllOrigins", url: (t) => `https://api.allorigins.win/get?url=${encodeURIComponent(t)}`, extract: (j) => JSON.parse(j.contents) },
            { name: "CodeTabs", url: (t) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(t)}`, extract: (j) => j },
            { name: "CorsProxy", url: (t) => `https://corsproxy.io/?${encodeURIComponent(t)}`, extract: (j) => j }
        ];

        async function fetchMalData() {
            const statusText = document.getElementById('status-text');
            const logArea = document.getElementById('log-area');
            const targetUrl = `https://api.jikan.moe/v4/users/${username}/animelist?limit=300`;

            let finalData = null;

            // 1. Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø¬Ù„Ø¨ Ø¹Ø¨Ø± Ø§Ù„ÙˆØ³Ø·Ø§Ø¡
            for (const proxy of proxies) {
                try {
                    statusText.innerText = `ØªØ¬Ø±Ø¨Ø© ${proxy.name}...`;
                    const response = await fetch(proxy.url(targetUrl));
                    if (!response.ok) throw new Error("HTTP Error");
                    const rawData = await response.json();
                    finalData = proxy.extract(rawData);
                    
                    if (finalData && finalData.data) {
                        logArea.innerText += `âœ… ${proxy.name}: Success (${finalData.data.length} items)\n`;
                        break;
                    }
                } catch (e) {
                    logArea.innerText += `âŒ ${proxy.name}: Failed\n`;
                }
            }

            if (!finalData || !finalData.data) {
                alert("ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„! ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø¥Ù†ØªØ±Ù†Øª.");
                window.location.href = "/";
                return;
            }

            // 2. Ù…Ø±Ø­Ù„Ø© Ø§Ù„ÙÙ„ØªØ±Ø© Ø§Ù„Ø°ÙƒÙŠØ© (Case Insensitive)
            const allAnime = finalData.data;
            statusText.innerText = `ÙˆØ¬Ø¯Ù†Ø§ ${allAnime.length} Ø£Ù†Ù…ÙŠ. Ø¬Ø§Ø±ÙŠ Ø§Ù„ÙØ±Ø²...`;

            // ØªÙˆØ­ÙŠØ¯ Ø§Ù„Ù†ØµÙˆØµ Ù„ØªÙƒÙˆÙ† Ø­Ø±ÙˆÙ ØµØºÙŠØ±Ø© (normalization)
            const normalize = (str) => String(str).toLowerCase().trim().replace(/[\s-_]/g, '');

            // Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø§Ù„Ù…Ø¨Ø³Ø·Ø©
            const targetMap = {
                'completed': ['completed', '2'],
                'watching': ['watching', '1'],
                'on_hold': ['onhold', 'on-hold', '3'],
                'dropped': ['dropped', '4']
            };

            let filteredIds = [];
            
            allAnime.forEach(item => {
                // ØªÙ†Ø¸ÙŠÙ Ø­Ø§Ù„Ø© Ø§Ù„Ø£Ù†Ù…ÙŠ Ø§Ù„Ù‚Ø§Ø¯Ù…Ø© Ù…Ù† Ø§Ù„Ù…ÙˆÙ‚Ø¹
                const rawStatus = item.status || ""; 
                const cleanStatus = normalize(rawStatus); 
                const animeId = item.anime.mal_id;

                let isMatch = false;
                selectedStatuses.forEach(reqStatus => {
                    // Ù…Ù‚Ø§Ø±Ù†Ø© Ù…Ø±Ù†Ø© Ø¬Ø¯Ø§Ù‹
                    const validValues = targetMap[reqStatus] || [];
                    if (validValues.includes(cleanStatus)) isMatch = true;
                });

                if (isMatch) filteredIds.push(animeId);
            });

            // Ø·Ø¨Ø§Ø¹Ø© ØªÙ‚Ø±ÙŠØ± ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„ÙØ´Ù„
            if (filteredIds.length === 0) {
                console.log("Debug: No matches found.");
                console.log("Sample Status from API:", allAnime[0]?.status);
                
                // fallback: Ø¥Ø°Ø§ Ù„Ù… Ù†Ø¬Ø¯ Ø´ÙŠØ¡ØŒ Ù†Ù‚Ø¨Ù„ ÙƒÙ„ Ø´ÙŠØ¡ Ù…Ø¤Ù‚ØªØ§Ù‹ Ù„Ù†Ø³Ù…Ø­ Ù„Ùƒ Ø¨Ø§Ù„Ù„Ø¹Ø¨
                if (confirm(`ØªØ­Ø°ÙŠØ±: Ù„Ù… ØªØªØ·Ø§Ø¨Ù‚ Ø§Ù„ÙÙ„Ø§ØªØ± Ø¨Ø¯Ù‚Ø©. Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ­Ù…ÙŠÙ„ ÙƒÙ„ Ø§Ù„Ø£Ù†Ù…ÙŠØ§Øª Ø§Ù„Ù€ ${allAnime.length} ÙˆØ§Ù„Ù„Ø¹Ø¨ØŸ`)) {
                    filteredIds = allAnime.map(i => i.anime.mal_id);
                } else {
                    window.location.href = "/";
                    return;
                }
            }

            // 3. Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ ÙˆØ§Ù„Ø¯Ø®ÙˆÙ„
            statusText.innerText = `ØªÙ… Ø§Ø¹ØªÙ…Ø§Ø¯ ${filteredIds.length} Ø£Ù†Ù…ÙŠ. Ø§Ù†Ø·Ù„Ù‚! ğŸš€`;
            
            await fetch('/save_mal_data', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ ids: filteredIds })
            });

            setTimeout(() => window.location.href = "/play?mode=mal_ready", 500);
        }

        fetchMalData();
    </script>
</body>
</html>